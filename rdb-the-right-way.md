## 5章
削除フラグのデメリット 

- 削除されていないレコードを取得するクエリの条件に`where delete_flag = 0`をつける必要がある
- `delete_flag`は1か0なのでカーディナリティが低くかつwhereの条件に含める必要があるので、パフォーマンスの低下につながる

解決策
- 別のテーブルに移し元のレコードからは削除する
  - RDBMSのトリガーを使う
- `where delete_flag = 0`のクエリをView化することで、アプリケーション側で削除フラグを意識しないようにする


## 6章
- ソートの処理は時間がかかる
- whereを使ってソートの対象レコードを限定する(where句狙い)
- あらかじめソートされているインデックスを利用する(order句狙い)

- P76 図6.3
  - ユーザーidがキー, 出身県idがバリューのIndexが貼ってあることが前提
  - (2)でこの7件になるのはなぜ? 
  - 図6.2と図6.3でクリエとレコードが同じだけど、where句狙いかorder句狙いかはRDBMSが決める?
    - 「狙う」ということは当たる場合もあるし、外れる場合もあるので↑はあっていそう


## 7章
- データにビジネスロジックを持たせない
- 責務ごとにテーブルを分ける
- 図7.2 子テーブルに親テーブルの外部キーがないけど、こういった構成もあるのか
## 8章
- 取り出す側でJSONをJSONとして扱いたい場合はアリ
- 極力正規化して単一のカラムに切り出す

## 9章
- Postgresqlはカラムに独自の型を定義できる
- ALTERでカラムの型を変更するが、一番強いlock(ACCESS EXCLUSIVE)を取るので、ロック中は他のクエリは実行できない
- デッドロックとは

  https://medium-company.com/%E3%83%87%E3%83%83%E3%83%89%E3%83%AD%E3%83%83%E3%82%AF/

- MySQLの場合

  https://www.slideshare.net/ichirin2501/ss-44642631

図9.4の自分用メモ
前提: トランザクションA, Bは同じタイミングで実行される
```
トランザクションA
INISERT INTO child VALUES(1,1)
UPDATE parent SET count =  count + 1 where id = 1

トランザクションB
INISERT INTO child VALUES(1,2)
UPDATE parent SET count =  count + 1 where id = 1

1. トランザクションA: INISERT INTO child VALUES(1,1)でINSERT
2. トランザクションB: INISERT INTO child VALUES(1,2)で親にロックがかかる
3. トランザクションA: 2で親にロックがかかっているため、UPDATEが待ちの状態になる
4. 親にロックがかかっているためトランザクションBでもUPDATEが待ちの状態になる
-> A,Bの両方で処理が止まってしまう(Deadlock!!)
```
- ビジネスロジックはアプリケーション側に持たせる
## 10章
- レプリケーションは本番DBの影響を受けるため、不正なデータが反映される レプリケーションとは別にデータそのもののバックアップが必要
- Gitlabデータ消失事件の概要
https://www.publickey1.jp/blog/17/gitlabcom56.html
- 障害発生した時に何をやるのかチームで認識を合わせる日を作っても良さそう

## 11章
- log設定ファイルを確認する
- どんなログが流れているか確認する
- どんな条件でslackでエラーに出るかを確認する
## 12章

## 13章

## 14章

## 15章

## 16章

## 17章

## 18章

## 19章

## 20章

