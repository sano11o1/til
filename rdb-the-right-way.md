## 5章
削除フラグのデメリット 

- 削除されていないレコードを取得するクエリの条件に`where delete_flag = 0`をつける必要がある
- `delete_flag`は1か0なのでカーディナリティが低くかつwhereの条件に含める必要があるので、パフォーマンスの低下につながる

解決策
- 別のテーブルに移し元のレコードからは削除する
  - RDBMSのトリガーを使う
- `where delete_flag = 0`のクエリをView化することで、アプリケーション側で削除フラグを意識しないようにする


## 6章
- ソートの処理は時間がかかる
- whereを使ってソートの対象レコードを限定する(where句狙い)
- あらかじめソートされているインデックスを利用する(order句狙い)

- P76 図6.3
  - ユーザーidがキー, 出身県idがバリューのIndexが貼ってあることが前提
  - (2)でこの7件になるのはなぜ? 
  - 図6.2と図6.3でクリエとレコードが同じだけど、where句狙いかorder句狙いかはRDBMSが決める?
    - 「狙う」ということは当たる場合もあるし、外れる場合もあるので↑はあっていそう


## 7章
- データにビジネスロジックを持たせない
- 責務ごとにテーブルを分ける
- 図7.2 子テーブルに親テーブルの外部キーがないけど、こういった構成もあるのか
## 8章
- 取り出す側でJSONをJSONとして扱いたい場合はアリ
- 極力正規化して単一のカラムに切り出す

## 9章

## 10章

## 11章

## 12章

## 13章

## 14章

## 15章

## 16章

## 17章

## 18章

## 19章

## 20章

